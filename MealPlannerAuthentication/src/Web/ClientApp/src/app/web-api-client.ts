//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountsClient {
    getLoginData(returnUrl: string): Observable<LoginDto>;
    login(command: LoginCommand): Observable<LoginResponse>;
    changePassword(changeUserPasswordCommand: ChangePasswordCommand): Observable<void>;
    forgotPassword(generatePasswordResetEmailCommand: ForgotPasswordCommand): Observable<void>;
    resetPassword(resetPasswordCommand: ResetPasswordCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountsClient implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getLoginData(returnUrl: string): Observable<LoginDto> {
        let url_ = this.baseUrl + "/api/Accounts/login?";
        if (returnUrl === undefined || returnUrl === null)
            throw new Error("The parameter 'returnUrl' must be defined and cannot be null.");
        else
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoginData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoginData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginDto>;
        }));
    }

    protected processGetLoginData(response: HttpResponseBase): Observable<LoginDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(command: LoginCommand): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/api/Accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePassword(changeUserPasswordCommand: ChangePasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeUserPasswordCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    forgotPassword(generatePasswordResetEmailCommand: ForgotPasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(generatePasswordResetEmailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPassword(resetPasswordCommand: ResetPasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Accounts/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetPasswordCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IBootstrapClient {
    getAngularApplicationSettings(): Observable<AngularSettingsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class BootstrapClient implements IBootstrapClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAngularApplicationSettings(): Observable<AngularSettingsDto> {
        let url_ = this.baseUrl + "/api/Bootstrap/angular-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAngularApplicationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAngularApplicationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AngularSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AngularSettingsDto>;
        }));
    }

    protected processGetAngularApplicationSettings(response: HttpResponseBase): Observable<AngularSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AngularSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IClaimsClient {
    hasClaim(claimName: string | null): Observable<boolean>;
    getUserClaims(userId: string): Observable<Claim[]>;
    addClaim(command: AddClaimCommand): Observable<void>;
    removeClaim(command: RemoveClaimCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ClaimsClient implements IClaimsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    hasClaim(claimName: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Claims?";
        if (claimName === undefined)
            throw new Error("The parameter 'claimName' must be defined.");
        else if(claimName !== null)
            url_ += "ClaimName=" + encodeURIComponent("" + claimName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processHasClaim(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserClaims(userId: string): Observable<Claim[]> {
        let url_ = this.baseUrl + "/api/Claims/user?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Claim[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Claim[]>;
        }));
    }

    protected processGetUserClaims(response: HttpResponseBase): Observable<Claim[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Claim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addClaim(command: AddClaimCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Claims/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddClaim(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeClaim(command: RemoveClaimCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Claims/remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveClaim(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IClientsClient {
    getClients(): Observable<ClientDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ClientsClient implements IClientsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getClients(): Observable<ClientDto[]> {
        let url_ = this.baseUrl + "/api/Clients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientDto[]>;
        }));
    }

    protected processGetClients(response: HttpResponseBase): Observable<ClientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IIdentitiesClient {
    getIdentityUser(userId: string): Observable<IdentityUserVM>;
    getIdentityUsers(): Observable<IdentityUserVM[]>;
    createIdentityUser(createUserCommand: CreateIdentityUserCommand): Observable<string>;
    updateIdentityUser(id: string, command: UpdateIdentityUserCommand): Observable<void>;
    deleteIdentityUser(id: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class IdentitiesClient implements IIdentitiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getIdentityUser(userId: string): Observable<IdentityUserVM> {
        let url_ = this.baseUrl + "/api/Identities?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdentityUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdentityUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityUserVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityUserVM>;
        }));
    }

    protected processGetIdentityUser(response: HttpResponseBase): Observable<IdentityUserVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUserVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getIdentityUsers(): Observable<IdentityUserVM[]> {
        let url_ = this.baseUrl + "/api/Identities/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdentityUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdentityUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityUserVM[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityUserVM[]>;
        }));
    }

    protected processGetIdentityUsers(response: HttpResponseBase): Observable<IdentityUserVM[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdentityUserVM.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createIdentityUser(createUserCommand: CreateIdentityUserCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Identities/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUserCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIdentityUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIdentityUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateIdentityUser(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateIdentityUser(id: string, command: UpdateIdentityUserCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Identities/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIdentityUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIdentityUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateIdentityUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteIdentityUser(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Identities/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIdentityUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIdentityUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteIdentityUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class LoginDto implements ILoginDto {
    allowRememberLogin?: boolean;
    enableLocalLogin?: boolean;
    externalProviders?: ExternalProvider[];
    visibleExternalProviders?: ExternalProvider[];
    isExternalLoginOnly?: boolean;
    externalLoginScheme?: string | undefined;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowRememberLogin = _data["allowRememberLogin"];
            this.enableLocalLogin = _data["enableLocalLogin"];
            if (Array.isArray(_data["externalProviders"])) {
                this.externalProviders = [] as any;
                for (let item of _data["externalProviders"])
                    this.externalProviders!.push(ExternalProvider.fromJS(item));
            }
            if (Array.isArray(_data["visibleExternalProviders"])) {
                this.visibleExternalProviders = [] as any;
                for (let item of _data["visibleExternalProviders"])
                    this.visibleExternalProviders!.push(ExternalProvider.fromJS(item));
            }
            this.isExternalLoginOnly = _data["isExternalLoginOnly"];
            this.externalLoginScheme = _data["externalLoginScheme"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowRememberLogin"] = this.allowRememberLogin;
        data["enableLocalLogin"] = this.enableLocalLogin;
        if (Array.isArray(this.externalProviders)) {
            data["externalProviders"] = [];
            for (let item of this.externalProviders)
                data["externalProviders"].push(item.toJSON());
        }
        if (Array.isArray(this.visibleExternalProviders)) {
            data["visibleExternalProviders"] = [];
            for (let item of this.visibleExternalProviders)
                data["visibleExternalProviders"].push(item.toJSON());
        }
        data["isExternalLoginOnly"] = this.isExternalLoginOnly;
        data["externalLoginScheme"] = this.externalLoginScheme;
        return data;
    }
}

export interface ILoginDto {
    allowRememberLogin?: boolean;
    enableLocalLogin?: boolean;
    externalProviders?: ExternalProvider[];
    visibleExternalProviders?: ExternalProvider[];
    isExternalLoginOnly?: boolean;
    externalLoginScheme?: string | undefined;
}

export class ExternalProvider implements IExternalProvider {
    displayName?: string | undefined;
    authenticationScheme?: string;

    constructor(data?: IExternalProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.authenticationScheme = _data["authenticationScheme"];
        }
    }

    static fromJS(data: any): ExternalProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["authenticationScheme"] = this.authenticationScheme;
        return data;
    }
}

export interface IExternalProvider {
    displayName?: string | undefined;
    authenticationScheme?: string;
}

export class LoginResponse implements ILoginResponse {
    isSuccess?: boolean;
    redirectUrl?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.redirectUrl = _data["redirectUrl"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["redirectUrl"] = this.redirectUrl;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ILoginResponse {
    isSuccess?: boolean;
    redirectUrl?: string | undefined;
    errorMessage?: string | undefined;
}

export class LoginCommand implements ILoginCommand {
    username?: string;
    password?: string;
    rememberLogin?: boolean;
    returnUrl?: string | undefined;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.rememberLogin = _data["rememberLogin"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["rememberLogin"] = this.rememberLogin;
        data["returnUrl"] = this.returnUrl;
        return data;
    }
}

export interface ILoginCommand {
    username?: string;
    password?: string;
    rememberLogin?: boolean;
    returnUrl?: string | undefined;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
    currentPassword?: string;
    newPassword?: string;
    confirmNewPassword?: string;

    constructor(data?: IChangePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmNewPassword = _data["confirmNewPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["confirmNewPassword"] = this.confirmNewPassword;
        return data;
    }
}

export interface IChangePasswordCommand {
    currentPassword?: string;
    newPassword?: string;
    confirmNewPassword?: string;
}

export class ForgotPasswordCommand implements IForgotPasswordCommand {
    email?: string;

    constructor(data?: IForgotPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordCommand {
    email?: string;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    resetToken?: string;
    email?: string;
    newPassword?: string;
    confirmNewPassword?: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resetToken = _data["resetToken"];
            this.email = _data["email"];
            this.newPassword = _data["newPassword"];
            this.confirmNewPassword = _data["confirmNewPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resetToken"] = this.resetToken;
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        data["confirmNewPassword"] = this.confirmNewPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    resetToken?: string;
    email?: string;
    newPassword?: string;
    confirmNewPassword?: string;
}

export class AngularSettingsDto implements IAngularSettingsDto {
    authority?: string;
    clientId?: string;
    scope?: string;

    constructor(data?: IAngularSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authority = _data["authority"];
            this.clientId = _data["clientId"];
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): AngularSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AngularSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authority"] = this.authority;
        data["clientId"] = this.clientId;
        data["scope"] = this.scope;
        return data;
    }
}

export interface IAngularSettingsDto {
    authority?: string;
    clientId?: string;
    scope?: string;
}

export class Claim implements IClaim {
    customSerializationData?: string | undefined;
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity | undefined;
    type?: string;
    value?: string;
    valueType?: string;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customSerializationData = _data["customSerializationData"];
            this.issuer = _data["issuer"];
            this.originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>undefined;
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customSerializationData"] = this.customSerializationData;
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface IClaim {
    customSerializationData?: string | undefined;
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity | undefined;
    type?: string;
    value?: string;
    valueType?: string;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    customSerializationData?: string | undefined;
    externalClaims?: Claim[][];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["authenticationType"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>undefined;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.customSerializationData = _data["customSerializationData"];
            if (Array.isArray(_data["externalClaims"])) {
                this.externalClaims = [] as any;
                for (let item of _data["externalClaims"])
                    this.externalClaims!.push(item);
            }
            this.label = _data["label"];
            this.name = _data["name"];
            this.nameClaimType = _data["nameClaimType"];
            this.roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["customSerializationData"] = this.customSerializationData;
        if (Array.isArray(this.externalClaims)) {
            data["externalClaims"] = [];
            for (let item of this.externalClaims)
                data["externalClaims"].push(item);
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    customSerializationData?: string | undefined;
    externalClaims?: Claim[][];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;
}

export class AddClaimCommand implements IAddClaimCommand {
    userId?: string;
    claim?: Claim;

    constructor(data?: IAddClaimCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.claim = _data["claim"] ? Claim.fromJS(_data["claim"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddClaimCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddClaimCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["claim"] = this.claim ? this.claim.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddClaimCommand {
    userId?: string;
    claim?: Claim;
}

export class RemoveClaimCommand implements IRemoveClaimCommand {
    userId?: string;
    claim?: Claim;

    constructor(data?: IRemoveClaimCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.claim = _data["claim"] ? Claim.fromJS(_data["claim"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RemoveClaimCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveClaimCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["claim"] = this.claim ? this.claim.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRemoveClaimCommand {
    userId?: string;
    claim?: Claim;
}

export class ClientDto implements IClientDto {
    clientId?: string | undefined;
    protocolType?: string | undefined;
    requireClientSecret?: boolean;
    clientName?: string | undefined;
    description?: string | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
    requireConsent?: boolean;
    allowRememberConsent?: boolean;
    alwaysIncludeUserClaimsInIdToken?: boolean;
    requirePkce?: boolean;
    allowPlainTextPkce?: boolean;
    requireRequestObject?: boolean;
    allowAccessTokensViaBrowser?: boolean;
    requireDPoP?: boolean;
    dPoPValidationMode?: number;
    dPoPClockSkew?: string;
    frontChannelLogoutUri?: string | undefined;
    frontChannelLogoutSessionRequired?: boolean;
    backChannelLogoutUri?: string | undefined;
    backChannelLogoutSessionRequired?: boolean;
    allowOfflineAccess?: boolean;
    identityTokenLifetime?: number;
    allowedIdentityTokenSigningAlgorithms?: string | undefined;
    accessTokenLifetime?: number;
    authorizationCodeLifetime?: number;
    consentLifetime?: number | undefined;
    absoluteRefreshTokenLifetime?: number;
    slidingRefreshTokenLifetime?: number;
    refreshTokenUsage?: number;
    updateAccessTokenClaimsOnRefresh?: boolean;
    refreshTokenExpiration?: number;
    accessTokenType?: number;
    enableLocalLogin?: boolean;
    includeJwtId?: boolean;
    alwaysSendClientClaims?: boolean;
    clientClaimsPrefix?: string | undefined;
    pairWiseSubjectSalt?: string | undefined;
    initiateLoginUri?: string | undefined;
    userSsoLifetime?: number | undefined;
    userCodeType?: string | undefined;
    deviceCodeLifetime?: number;
    cibaLifetime?: number | undefined;
    pollingInterval?: number | undefined;
    coordinateLifetimeWithUserSession?: boolean | undefined;
    created?: Date;
    updated?: Date | undefined;
    lastAccessed?: Date | undefined;
    nonEditable?: boolean;
    pushedAuthorizationLifetime?: number | undefined;
    requirePushedAuthorization?: boolean;

    constructor(data?: IClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.protocolType = _data["protocolType"];
            this.requireClientSecret = _data["requireClientSecret"];
            this.clientName = _data["clientName"];
            this.description = _data["description"];
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
            this.requireConsent = _data["requireConsent"];
            this.allowRememberConsent = _data["allowRememberConsent"];
            this.alwaysIncludeUserClaimsInIdToken = _data["alwaysIncludeUserClaimsInIdToken"];
            this.requirePkce = _data["requirePkce"];
            this.allowPlainTextPkce = _data["allowPlainTextPkce"];
            this.requireRequestObject = _data["requireRequestObject"];
            this.allowAccessTokensViaBrowser = _data["allowAccessTokensViaBrowser"];
            this.requireDPoP = _data["requireDPoP"];
            this.dPoPValidationMode = _data["dPoPValidationMode"];
            this.dPoPClockSkew = _data["dPoPClockSkew"];
            this.frontChannelLogoutUri = _data["frontChannelLogoutUri"];
            this.frontChannelLogoutSessionRequired = _data["frontChannelLogoutSessionRequired"];
            this.backChannelLogoutUri = _data["backChannelLogoutUri"];
            this.backChannelLogoutSessionRequired = _data["backChannelLogoutSessionRequired"];
            this.allowOfflineAccess = _data["allowOfflineAccess"];
            this.identityTokenLifetime = _data["identityTokenLifetime"];
            this.allowedIdentityTokenSigningAlgorithms = _data["allowedIdentityTokenSigningAlgorithms"];
            this.accessTokenLifetime = _data["accessTokenLifetime"];
            this.authorizationCodeLifetime = _data["authorizationCodeLifetime"];
            this.consentLifetime = _data["consentLifetime"];
            this.absoluteRefreshTokenLifetime = _data["absoluteRefreshTokenLifetime"];
            this.slidingRefreshTokenLifetime = _data["slidingRefreshTokenLifetime"];
            this.refreshTokenUsage = _data["refreshTokenUsage"];
            this.updateAccessTokenClaimsOnRefresh = _data["updateAccessTokenClaimsOnRefresh"];
            this.refreshTokenExpiration = _data["refreshTokenExpiration"];
            this.accessTokenType = _data["accessTokenType"];
            this.enableLocalLogin = _data["enableLocalLogin"];
            this.includeJwtId = _data["includeJwtId"];
            this.alwaysSendClientClaims = _data["alwaysSendClientClaims"];
            this.clientClaimsPrefix = _data["clientClaimsPrefix"];
            this.pairWiseSubjectSalt = _data["pairWiseSubjectSalt"];
            this.initiateLoginUri = _data["initiateLoginUri"];
            this.userSsoLifetime = _data["userSsoLifetime"];
            this.userCodeType = _data["userCodeType"];
            this.deviceCodeLifetime = _data["deviceCodeLifetime"];
            this.cibaLifetime = _data["cibaLifetime"];
            this.pollingInterval = _data["pollingInterval"];
            this.coordinateLifetimeWithUserSession = _data["coordinateLifetimeWithUserSession"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
            this.lastAccessed = _data["lastAccessed"] ? new Date(_data["lastAccessed"].toString()) : <any>undefined;
            this.nonEditable = _data["nonEditable"];
            this.pushedAuthorizationLifetime = _data["pushedAuthorizationLifetime"];
            this.requirePushedAuthorization = _data["requirePushedAuthorization"];
        }
    }

    static fromJS(data: any): ClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["protocolType"] = this.protocolType;
        data["requireClientSecret"] = this.requireClientSecret;
        data["clientName"] = this.clientName;
        data["description"] = this.description;
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        data["requireConsent"] = this.requireConsent;
        data["allowRememberConsent"] = this.allowRememberConsent;
        data["alwaysIncludeUserClaimsInIdToken"] = this.alwaysIncludeUserClaimsInIdToken;
        data["requirePkce"] = this.requirePkce;
        data["allowPlainTextPkce"] = this.allowPlainTextPkce;
        data["requireRequestObject"] = this.requireRequestObject;
        data["allowAccessTokensViaBrowser"] = this.allowAccessTokensViaBrowser;
        data["requireDPoP"] = this.requireDPoP;
        data["dPoPValidationMode"] = this.dPoPValidationMode;
        data["dPoPClockSkew"] = this.dPoPClockSkew;
        data["frontChannelLogoutUri"] = this.frontChannelLogoutUri;
        data["frontChannelLogoutSessionRequired"] = this.frontChannelLogoutSessionRequired;
        data["backChannelLogoutUri"] = this.backChannelLogoutUri;
        data["backChannelLogoutSessionRequired"] = this.backChannelLogoutSessionRequired;
        data["allowOfflineAccess"] = this.allowOfflineAccess;
        data["identityTokenLifetime"] = this.identityTokenLifetime;
        data["allowedIdentityTokenSigningAlgorithms"] = this.allowedIdentityTokenSigningAlgorithms;
        data["accessTokenLifetime"] = this.accessTokenLifetime;
        data["authorizationCodeLifetime"] = this.authorizationCodeLifetime;
        data["consentLifetime"] = this.consentLifetime;
        data["absoluteRefreshTokenLifetime"] = this.absoluteRefreshTokenLifetime;
        data["slidingRefreshTokenLifetime"] = this.slidingRefreshTokenLifetime;
        data["refreshTokenUsage"] = this.refreshTokenUsage;
        data["updateAccessTokenClaimsOnRefresh"] = this.updateAccessTokenClaimsOnRefresh;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration;
        data["accessTokenType"] = this.accessTokenType;
        data["enableLocalLogin"] = this.enableLocalLogin;
        data["includeJwtId"] = this.includeJwtId;
        data["alwaysSendClientClaims"] = this.alwaysSendClientClaims;
        data["clientClaimsPrefix"] = this.clientClaimsPrefix;
        data["pairWiseSubjectSalt"] = this.pairWiseSubjectSalt;
        data["initiateLoginUri"] = this.initiateLoginUri;
        data["userSsoLifetime"] = this.userSsoLifetime;
        data["userCodeType"] = this.userCodeType;
        data["deviceCodeLifetime"] = this.deviceCodeLifetime;
        data["cibaLifetime"] = this.cibaLifetime;
        data["pollingInterval"] = this.pollingInterval;
        data["coordinateLifetimeWithUserSession"] = this.coordinateLifetimeWithUserSession;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["lastAccessed"] = this.lastAccessed ? this.lastAccessed.toISOString() : <any>undefined;
        data["nonEditable"] = this.nonEditable;
        data["pushedAuthorizationLifetime"] = this.pushedAuthorizationLifetime;
        data["requirePushedAuthorization"] = this.requirePushedAuthorization;
        return data;
    }
}

export interface IClientDto {
    clientId?: string | undefined;
    protocolType?: string | undefined;
    requireClientSecret?: boolean;
    clientName?: string | undefined;
    description?: string | undefined;
    clientUri?: string | undefined;
    logoUri?: string | undefined;
    requireConsent?: boolean;
    allowRememberConsent?: boolean;
    alwaysIncludeUserClaimsInIdToken?: boolean;
    requirePkce?: boolean;
    allowPlainTextPkce?: boolean;
    requireRequestObject?: boolean;
    allowAccessTokensViaBrowser?: boolean;
    requireDPoP?: boolean;
    dPoPValidationMode?: number;
    dPoPClockSkew?: string;
    frontChannelLogoutUri?: string | undefined;
    frontChannelLogoutSessionRequired?: boolean;
    backChannelLogoutUri?: string | undefined;
    backChannelLogoutSessionRequired?: boolean;
    allowOfflineAccess?: boolean;
    identityTokenLifetime?: number;
    allowedIdentityTokenSigningAlgorithms?: string | undefined;
    accessTokenLifetime?: number;
    authorizationCodeLifetime?: number;
    consentLifetime?: number | undefined;
    absoluteRefreshTokenLifetime?: number;
    slidingRefreshTokenLifetime?: number;
    refreshTokenUsage?: number;
    updateAccessTokenClaimsOnRefresh?: boolean;
    refreshTokenExpiration?: number;
    accessTokenType?: number;
    enableLocalLogin?: boolean;
    includeJwtId?: boolean;
    alwaysSendClientClaims?: boolean;
    clientClaimsPrefix?: string | undefined;
    pairWiseSubjectSalt?: string | undefined;
    initiateLoginUri?: string | undefined;
    userSsoLifetime?: number | undefined;
    userCodeType?: string | undefined;
    deviceCodeLifetime?: number;
    cibaLifetime?: number | undefined;
    pollingInterval?: number | undefined;
    coordinateLifetimeWithUserSession?: boolean | undefined;
    created?: Date;
    updated?: Date | undefined;
    lastAccessed?: Date | undefined;
    nonEditable?: boolean;
    pushedAuthorizationLifetime?: number | undefined;
    requirePushedAuthorization?: boolean;
}

export class IdentityUserVM implements IIdentityUserVM {
    identityUser?: IdentityUserDto | undefined;
    roleClaims?: string[];
    systemClaims?: string[];

    constructor(data?: IIdentityUserVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.identityUser = _data["identityUser"] ? IdentityUserDto.fromJS(_data["identityUser"]) : <any>undefined;
            if (Array.isArray(_data["roleClaims"])) {
                this.roleClaims = [] as any;
                for (let item of _data["roleClaims"])
                    this.roleClaims!.push(item);
            }
            if (Array.isArray(_data["systemClaims"])) {
                this.systemClaims = [] as any;
                for (let item of _data["systemClaims"])
                    this.systemClaims!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityUserVM {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["identityUser"] = this.identityUser ? this.identityUser.toJSON() : <any>undefined;
        if (Array.isArray(this.roleClaims)) {
            data["roleClaims"] = [];
            for (let item of this.roleClaims)
                data["roleClaims"].push(item);
        }
        if (Array.isArray(this.systemClaims)) {
            data["systemClaims"] = [];
            for (let item of this.systemClaims)
                data["systemClaims"].push(item);
        }
        return data;
    }
}

export interface IIdentityUserVM {
    identityUser?: IdentityUserDto | undefined;
    roleClaims?: string[];
    systemClaims?: string[];
}

export class IdentityUserDto implements IIdentityUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;

    constructor(data?: IIdentityUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }
}

export interface IIdentityUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
}

export class CreateIdentityUserCommand implements ICreateIdentityUserCommand {
    email?: string | undefined;
    roleClaims?: string[] | undefined;
    systemClaims?: string[] | undefined;

    constructor(data?: ICreateIdentityUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            if (Array.isArray(_data["roleClaims"])) {
                this.roleClaims = [] as any;
                for (let item of _data["roleClaims"])
                    this.roleClaims!.push(item);
            }
            if (Array.isArray(_data["systemClaims"])) {
                this.systemClaims = [] as any;
                for (let item of _data["systemClaims"])
                    this.systemClaims!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateIdentityUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIdentityUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        if (Array.isArray(this.roleClaims)) {
            data["roleClaims"] = [];
            for (let item of this.roleClaims)
                data["roleClaims"].push(item);
        }
        if (Array.isArray(this.systemClaims)) {
            data["systemClaims"] = [];
            for (let item of this.systemClaims)
                data["systemClaims"].push(item);
        }
        return data;
    }
}

export interface ICreateIdentityUserCommand {
    email?: string | undefined;
    roleClaims?: string[] | undefined;
    systemClaims?: string[] | undefined;
}

export class UpdateIdentityUserCommand implements IUpdateIdentityUserCommand {
    userId?: string;
    email?: string;
    roleClaims?: string[];
    systemClaims?: string[];

    constructor(data?: IUpdateIdentityUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            if (Array.isArray(_data["roleClaims"])) {
                this.roleClaims = [] as any;
                for (let item of _data["roleClaims"])
                    this.roleClaims!.push(item);
            }
            if (Array.isArray(_data["systemClaims"])) {
                this.systemClaims = [] as any;
                for (let item of _data["systemClaims"])
                    this.systemClaims!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateIdentityUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIdentityUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        if (Array.isArray(this.roleClaims)) {
            data["roleClaims"] = [];
            for (let item of this.roleClaims)
                data["roleClaims"].push(item);
        }
        if (Array.isArray(this.systemClaims)) {
            data["systemClaims"] = [];
            for (let item of this.systemClaims)
                data["systemClaims"].push(item);
        }
        return data;
    }
}

export interface IUpdateIdentityUserCommand {
    userId?: string;
    email?: string;
    roleClaims?: string[];
    systemClaims?: string[];
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}